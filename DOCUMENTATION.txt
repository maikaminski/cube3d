================================================================================
                    CUB3D - DOCUMENTA√á√ÉO COMPLETA
                    Explica√ß√£o Detalhada de Todas as Fun√ß√µes
================================================================================

üìö VIS√ÉO GERAL DO PROJETO
================================================================================

O **cub3D** √© um motor de raycasting 3D inspirado no jogo Wolfenstein 3D. 
Ele cria uma vis√£o em primeira pessoa de um labirinto 2D, renderizando 
paredes texturizadas em 3D usando a t√©cnica de raycasting.

================================================================================
üìÅ ESTRUTURA DE ARQUIVOS
================================================================================

src/
‚îú‚îÄ‚îÄ main.c                      # Ponto de entrada e inicializa√ß√£o
‚îú‚îÄ‚îÄ parsing/                    # Leitura e valida√ß√£o do arquivo .cub
‚îÇ   ‚îú‚îÄ‚îÄ file_parser.c          # Parser principal do arquivo
‚îÇ   ‚îú‚îÄ‚îÄ map_parser.c           # Parser espec√≠fico do mapa
‚îÇ   ‚îú‚îÄ‚îÄ texture_parser.c       # Parser de texturas e cores
‚îÇ   ‚îú‚îÄ‚îÄ texture_utils.c        # Fun√ß√µes auxiliares de parsing
‚îÇ   ‚îú‚îÄ‚îÄ validation.c           # Valida√ß√£o do mapa
‚îÇ   ‚îú‚îÄ‚îÄ wall_check.c          # Verifica√ß√£o de paredes
‚îÇ   ‚îî‚îÄ‚îÄ init_player.c         # Inicializa√ß√£o do jogador
‚îú‚îÄ‚îÄ raycasting/                # Motor de raycasting
‚îÇ   ‚îú‚îÄ‚îÄ raycasting.c          # Algoritmo principal
‚îÇ   ‚îî‚îÄ‚îÄ dda.c                 # Digital Differential Analysis
‚îú‚îÄ‚îÄ graphics/                  # Renderiza√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ renderer.c            # Renderizador principal
‚îÇ   ‚îú‚îÄ‚îÄ draw_wall.c          # Desenho de paredes
‚îÇ   ‚îú‚îÄ‚îÄ textures.c           # Carregamento de texturas
‚îÇ   ‚îú‚îÄ‚îÄ minimap.c            # Minimapa (bonus)
‚îÇ   ‚îî‚îÄ‚îÄ minimap_utils.c      # Utilidades do minimapa
‚îú‚îÄ‚îÄ player/                   # Controles do jogador
‚îÇ   ‚îú‚îÄ‚îÄ movement.c           # Movimenta√ß√£o
‚îÇ   ‚îî‚îÄ‚îÄ collision.c          # Detec√ß√£o de colis√£o
‚îî‚îÄ‚îÄ utils/                   # Utilit√°rios gerais
    ‚îú‚îÄ‚îÄ cleanup.c           # Limpeza de mem√≥ria
    ‚îú‚îÄ‚îÄ error.c            # Tratamento de erros
    ‚îî‚îÄ‚îÄ math_utils.c       # Fun√ß√µes matem√°ticas

================================================================================
üöÄ 1. MAIN.C - Ponto de Entrada
================================================================================

--------------------------------------------------------------------------------
int main(int argc, char **argv)
--------------------------------------------------------------------------------
PROP√ìSITO: Fun√ß√£o principal que inicia o programa

FUNCIONAMENTO DETALHADO:
1. Valida argumentos (linha 17-22):
   - Verifica se foi passado exatamente 1 argumento (o arquivo .cub)
   - Se n√£o, imprime erro e retorna 1
   
2. Valida extens√£o (linha 23-27):
   - Chama validate_extension() para verificar se o arquivo termina em .cub
   - Se inv√°lido, imprime erro e retorna 1

3. Inicializa estrutura do jogo (linha 28):
   - Chama init_game() para alocar e preparar todas as estruturas necess√°rias
   - Inicializa MLX, janela, imagens, texturas, jogador

4. Faz parsing do arquivo (linha 29-34):
   - Chama parse_file() para ler e processar o arquivo .cub
   - Se falhar, limpa mem√≥ria e retorna 1

5. Inicia loop do jogo (linha 35):
   - Chama game_loop() que configura hooks e inicia loop infinito

6. Cleanup (linha 36):
   - Ap√≥s o loop terminar (janela fechada), limpa toda a mem√≥ria alocada

--------------------------------------------------------------------------------
static void init_textures(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Inicializa a estrutura de texturas

FUNCIONAMENTO:
1. Aloca mem√≥ria para t_texture (4 ponteiros para imagens)
2. Inicializa todos os ponteiros como NULL
3. Se falhar aloca√ß√£o, chama error_exit()

--------------------------------------------------------------------------------
static void init_keys(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Inicializa array de teclas pressionadas

FUNCIONAMENTO:
1. Percorre array de 256 posi√ß√µes (uma para cada c√≥digo de tecla)
2. Define todas como 0 (n√£o pressionada)
3. Usado depois para controles: game->keys[KEY_W] retorna 1 se W est√° pressionado

--------------------------------------------------------------------------------
void init_game(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Inicializa todas as estruturas principais do jogo

FUNCIONAMENTO DETALHADO:
1. Inicializa MLX (linha 61-63):
   - mlx_init() cria conex√£o com o servidor X11
   - Se falhar, termina programa

2. Cria janela (linha 64-67):
   - mlx_new_window() cria janela de 1024x768 pixels
   - T√≠tulo: "Cub3D"

3. Cria buffer de imagem (linha 68-75):
   - Aloca estrutura t_img
   - mlx_new_image() cria buffer onde vamos desenhar
   - mlx_get_data_addr() obt√©m ponteiro direto para os pixels
   - Isso permite modificar pixels diretamente na mem√≥ria

4. Inicializa texturas (linha 76):
   - Chama init_textures() para preparar estrutura

5. Aloca jogador (linha 77-79):
   - Aloca mem√≥ria para estrutura t_player
   - Posi√ß√£o, dire√ß√£o e plano de c√¢mera ser√£o definidos depois

6. Inicializa controles (linha 80):
   - Chama init_keys() para zerar array de teclas

--------------------------------------------------------------------------------
void game_loop(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Configura hooks de eventos e inicia loop principal

FUNCIONAMENTO:
1. Hook de tecla pressionada (linha 85):
   - mlx_hook(..., 2, ...) - Evento KeyPress
   - Quando tecla √© pressionada, chama key_press()

2. Hook de tecla solta (linha 86):
   - mlx_hook(..., 3, ...) - Evento KeyRelease
   - Quando tecla √© solta, chama key_release()

3. Hook de fechar janela (linha 87):
   - mlx_hook(..., 17, ...) - Evento DestroyNotify
   - Quando clica no X da janela, chama close_window()

4. Hook de renderiza√ß√£o (linha 88):
   - mlx_loop_hook() - Chamado continuamente
   - Chama render_frame() a cada frame (~60 FPS)

5. Inicia loop (linha 89):
   - mlx_loop() - Loop infinito que processa eventos
   - S√≥ termina quando janela √© fechada

================================================================================
üìñ 2. PARSING - Leitura do Arquivo .cub
================================================================================

--------------------------------------------------------------------------------
FILE_PARSER.C
--------------------------------------------------------------------------------

static void free_lines(char **lines)
--------------------------------------------------------------------------------
PROP√ìSITO: Libera array de strings

FUNCIONAMENTO:
1. Verifica se lines n√£o √© NULL
2. Percorre cada string e libera com free()
3. Libera o array principal

--------------------------------------------------------------------------------
static char **read_lines(int fd)
--------------------------------------------------------------------------------
PROP√ìSITO: L√™ todas as linhas do arquivo

FUNCIONAMENTO:
1. Aloca array para 1000 linhas (m√°ximo)
2. Loop usando get_next_line():
   - L√™ linha por linha
   - Armazena cada linha no array
   - Para quando retorna NULL (fim do arquivo)
3. Adiciona NULL no final do array
4. Retorna array de strings

--------------------------------------------------------------------------------
static int validate_all(char **lines, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Valida todo o conte√∫do do arquivo

FUNCIONAMENTO SEQUENCIAL:
1. Parse texturas (linha 55-60):
   - Chama parse_textures() para extrair NO, SO, WE, EA, F, C
   - Se falhar, libera linhas e retorna 0

2. Valida texturas (linha 61-65):
   - Verifica se todas as 4 texturas foram carregadas
   - Se falhar, libera e retorna 0

3. Parse mapa (linha 66-70):
   - Chama parse_map() para extrair o mapa 2D
   - Se falhar, libera e retorna 0

4. Valida mapa (linha 71-75):
   - Verifica se mapa √© v√°lido (fechado, 1 jogador, etc.)
   - Se falhar, libera e retorna 0

5. Retorna 1 se tudo passar

--------------------------------------------------------------------------------
int parse_file(char *filename, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Fun√ß√£o principal que coordena o parsing

FUNCIONAMENTO:
1. Abre arquivo (linha 80):
   - open() em modo leitura
   - Se falhar, termina com erro

2. L√™ todas as linhas (linha 86):
   - Chama read_lines() para carregar arquivo na mem√≥ria

3. Fecha arquivo (linha 87):
   - N√£o precisa mais do fd, fecha imediatamente

4. Valida conte√∫do (linha 88):
   - Chama validate_all() que faz todo o processamento

5. Cleanup (linha 89):
   - Libera array de linhas

6. Retorna resultado da valida√ß√£o

--------------------------------------------------------------------------------
int validate_extension(char *filename)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se arquivo termina em .cub

FUNCIONAMENTO:
1. Calcula tamanho do nome
2. Se menor que 4 caracteres, retorna 0
3. Compara √∫ltimos 4 caracteres com ".cub"
4. Retorna 1 se igual, 0 se diferente

--------------------------------------------------------------------------------
MAP_PARSER.C
--------------------------------------------------------------------------------

static int is_blank_line(char *line)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se linha cont√©m apenas espa√ßos em branco

FUNCIONAMENTO:
1. Percorre cada caractere
2. Verifica se √© espa√ßo, tab, newline ou carriage return
3. Retorna 1 se linha est√° vazia, 0 se tem conte√∫do

--------------------------------------------------------------------------------
static int is_config_line(char *line)
--------------------------------------------------------------------------------
PROP√ìSITO: Identifica se linha √© configura√ß√£o (textura ou cor)

FUNCIONAMENTO:
1. Verifica se come√ßa com "NO ", "SO ", "WE ", "EA " (texturas)
2. Ou se come√ßa com "F " ou "C " (cores)
3. Retorna 1 se for configura√ß√£o, 0 se n√£o

--------------------------------------------------------------------------------
static int find_map_start(char **lines)
--------------------------------------------------------------------------------
PROP√ìSITO: Encontra onde o mapa come√ßa no arquivo

FUNCIONAMENTO:
1. Come√ßa do √≠ndice 0
2. Pula todas as linhas que s√£o:
   - Linhas de configura√ß√£o
   - Linhas em branco
3. Retorna √≠ndice da primeira linha do mapa

EXEMPLO:
NO ./texture_north.xpm    <- config, pula
SO ./texture_south.xpm    <- config, pula
F 100,100,100             <- config, pula
                          <- blank, pula
111111                    <- mapa! retorna este √≠ndice
100001

--------------------------------------------------------------------------------
static void copy_map_lines(char **lines, t_game *game, int map_start)
--------------------------------------------------------------------------------
PROP√ìSITO: Copia linhas do mapa para estrutura do jogo

FUNCIONAMENTO:
1. Loop de 0 at√© map_height
2. Para cada linha, faz ft_strdup() para copiar
3. Armazena em game->map[i]
4. Adiciona NULL no final

--------------------------------------------------------------------------------
int parse_map(char **lines, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Extrai e processa o mapa do arquivo

FUNCIONAMENTO DETALHADO:
1. Encontra in√≠cio (linha 59):
   - Chama find_map_start() para achar primeira linha do mapa

2. Calcula altura (linha 60-63):
   - Conta quantas linhas existem do in√≠cio at√© o fim
   - map_height = n√∫mero de linhas do mapa

3. Calcula largura (linha 64-70):
   - Percorre todas as linhas do mapa
   - Encontra a linha mais longa
   - map_width = tamanho da maior linha

4. Aloca mem√≥ria (linha 71-73):
   - Aloca array de ponteiros (map_height + 1)
   - +1 para NULL no final

5. Copia linhas (linha 74):
   - Chama copy_map_lines() para copiar mapa

POR QUE PRECISAMOS DE MAP_WIDTH?
- Mapas podem ter linhas de tamanhos diferentes
- Precisamos saber o tamanho m√°ximo para valida√ß√£o

--------------------------------------------------------------------------------
TEXTURE_PARSER.C
--------------------------------------------------------------------------------

int validate_textures(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se todas as 4 texturas foram carregadas

FUNCIONAMENTO:
1. Verifica se algum ponteiro √© NULL
2. Se algum for NULL, erro
3. Retorna 1 se todas existem

--------------------------------------------------------------------------------
int parse_textures(char **lines, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Processa todas as linhas de configura√ß√£o

FUNCIONAMENTO:
1. Inicializa contador found = 0 (precisa encontrar 6: NO, SO, WE, EA, F, C)
2. Loop pelas linhas enquanto found < 6
3. Para cada linha, chama parse_config_line() que:
   - Identifica tipo da linha
   - Processa apropriadamente
   - Incrementa found se v√°lida
4. Retorna 1 se encontrou todas as 6

--------------------------------------------------------------------------------
int parse_color(char *color_str, t_color *color)
--------------------------------------------------------------------------------
PROP√ìSITO: Converte string "R,G,B" em estrutura de cor

FUNCIONAMENTO DETALHADO:
1. Split (linha 39):
   - ft_split(color_str, ',') divide em ["R", "G", "B"]

2. Valida formato (linha 40-41):
   - Verifica se tem exatamente 3 componentes
   - Se n√£o, retorna 0

3. Converte para inteiros (linha 42-44):
   - ft_atoi() em cada componente
   - Armazena em color->r, color->g, color->b

4. Valida range (linha 45-48):
   - Cada componente deve estar entre 0-255
   - Se fora do range, retorna 0

5. Cria hex (linha 49):
   - create_rgb() combina R,G,B em um √∫nico int
   - Formato: 0xRRGGBB
   - Exemplo: R=255, G=100, B=50 ‚Üí 0xFF6432

6. Libera mem√≥ria (linha 50-55):
   - Libera cada string do split
   - Libera array principal

EXEMPLO:
Input: "100,150,200"
Split: ["100", "150", "200"]
Convert: r=100, g=150, b=200
Hex: 0x6496C8

--------------------------------------------------------------------------------
VALIDATION.C
--------------------------------------------------------------------------------

static int check_char_valid(t_game *game, int i, int j, int *player_count)
--------------------------------------------------------------------------------
PROP√ìSITO: Valida cada caractere do mapa

FUNCIONAMENTO:
1. Verifica se √© jogador (linha 16-21):
   - Se caractere √© N, S, E ou W
   - Incrementa contador de jogadores
   - Chama init_player() para inicializar posi√ß√£o e dire√ß√£o
   - Retorna 1 (v√°lido)

2. Verifica outros caracteres (linha 22-29):
   - Caracteres v√°lidos: '0', '1', ' ', '\n', '\t', '\r'
   - Se for inv√°lido, imprime erro detalhado com posi√ß√£o
   - Retorna 0 (inv√°lido)

3. Retorna 1 se caractere √© v√°lido

--------------------------------------------------------------------------------
int validate_map(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Valida todo o mapa

FUNCIONAMENTO DETALHADO:
1. Inicializa (linha 35):
   - player_count = 0 para contar jogadores

2. Loop duplo (linha 36-46):
   - Percorre cada linha (i) e cada coluna (j)
   - Para cada caractere, chama check_char_valid()
   - Se retornar 0, para e retorna 0

3. Valida n√∫mero de jogadores (linha 47-52):
   - Deve ter EXATAMENTE 1 jogador
   - Se 0 ou >1, imprime erro e retorna 0

4. Valida paredes (linha 53):
   - Chama check_walls() para verificar se mapa √© fechado
   - Retorna resultado

POR QUE EXATAMENTE 1 JOGADOR?
- 0 jogadores: n√£o h√° onde come√ßar
- >1 jogadores: ambiguidade de spawn

--------------------------------------------------------------------------------
int check_walls(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se mapa est√° cercado por paredes

FUNCIONAMENTO:
1. Verifica paredes superior e inferior com check_top_bottom_walls()
2. Verifica paredes laterais com check_side_walls()
3. Retorna 1 apenas se ambos passarem

--------------------------------------------------------------------------------
WALL_CHECK.C
--------------------------------------------------------------------------------

static int check_top_wall(t_game *game, int i)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se a primeira linha do mapa est√° fechada na posi√ß√£o i

FUNCIONAMENTO:
1. Verifica se √≠ndice i existe na primeira linha
2. Checa se o caractere √© v√°lido para borda (deve ser '1' ou espa√ßo)
3. Se for '0' ou outro inv√°lido, imprime erro detalhado
4. Retorna 0 se inv√°lido, 1 se v√°lido

POR QUE ACEITAR ESPA√áOS?
   111
  10001    <- Espa√ßos antes s√£o v√°lidos (fora do mapa)
  11111

--------------------------------------------------------------------------------
static int check_bottom_wall(t_game *game, int i)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se a √∫ltima linha do mapa est√° fechada na posi√ß√£o i

FUNCIONAMENTO:
1. Calcula row = map_height - 1 (√∫ltima linha)
2. Mesma l√≥gica que check_top_wall() mas para linha inferior
3. Retorna 0 se inv√°lido, 1 se v√°lido

--------------------------------------------------------------------------------
int check_top_bottom_walls(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Valida que topo e fundo est√£o completamente fechados

FUNCIONAMENTO:
1. Loop de 0 at√© map_width
2. Para cada coluna i:
   - Verifica topo com check_top_wall()
   - Verifica fundo com check_bottom_wall()
3. Se qualquer falhar, retorna 0
4. Retorna 1 se todos passarem

VISUALIZA√á√ÉO:
111111    <- Verifica cada posi√ß√£o desta linha
100001
100N01
111111    <- E cada posi√ß√£o desta linha

--------------------------------------------------------------------------------
static int check_right_edge(t_game *game, int i)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se o lado direito da linha i est√° fechado

FUNCIONAMENTO:
1. Pega √∫ltimo caractere da linha i
2. Verifica se √© '1' ou espa√ßo
3. Se n√£o, erro e retorna 0
4. Retorna 1 se v√°lido

--------------------------------------------------------------------------------
int check_side_walls(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Valida que laterais esquerda e direita est√£o fechadas

FUNCIONAMENTO:
1. Loop por cada linha do mapa
2. Para cada linha:
   - Esquerda: Verifica se primeiro caractere √© '1' ou espa√ßo
   - Direita: Chama check_right_edge()
3. Se qualquer falhar, retorna 0
4. Retorna 1 se todos passarem

VISUALIZA√á√ÉO:
1        <- Verifica primeiro char
1        <- De cada linha
1
1        <- At√© a √∫ltima

--------------------------------------------------------------------------------
INIT_PLAYER.C
--------------------------------------------------------------------------------

static void init_player_dir_ns(t_game *game, char direction)
--------------------------------------------------------------------------------
PROP√ìSITO: Inicializa dire√ß√£o e plano de c√¢mera para Norte/Sul

FUNCIONAMENTO DETALHADO:

SE DIRECTION == 'N' (Norte):
- dir_x = 0, dir_y = -1: Olhando para cima (Y negativo)
- plane_x = 0.66, plane_y = 0: Plano de c√¢mera perpendicular
- FOV de ~66 graus (0.66 radianos)

SE DIRECTION == 'S' (Sul):
- dir_x = 0, dir_y = 1: Olhando para baixo (Y positivo)
- plane_x = -0.66, plane_y = 0: Plano invertido

O QUE √â O PLANO DE C√ÇMERA?
- Vetor perpendicular √† dire√ß√£o de vis√£o
- Define o campo de vis√£o (FOV)
- Maior valor = FOV mais amplo

DIAGRAMA:
       plane
      ‚Üê--‚Üí
      |  |
      |  | dir (Norte)
      ‚Üë  |
    Player

--------------------------------------------------------------------------------
static void init_player_dir_ew(t_game *game, char direction)
--------------------------------------------------------------------------------
PROP√ìSITO: Inicializa dire√ß√£o e plano de c√¢mera para Leste/Oeste

SE DIRECTION == 'E' (Leste):
- dir_x = 1, dir_y = 0: Olhando para direita
- plane_x = 0, plane_y = 0.66

SE DIRECTION == 'W' (Oeste):
- dir_x = -1, dir_y = 0: Olhando para esquerda
- plane_x = 0, plane_y = -0.66

--------------------------------------------------------------------------------
void init_player(t_game *game, int y, int x, char direction)
--------------------------------------------------------------------------------
PROP√ìSITO: Configura posi√ß√£o e orienta√ß√£o inicial do jogador

FUNCIONAMENTO:
1. Define posi√ß√£o (linha 52-53):
   - x + 0.5, y + 0.5: Centro da c√©lula
   - Exemplo: c√©lula (5,3) ‚Üí posi√ß√£o (5.5, 3.5)

2. Define dire√ß√£o (linha 54-55):
   - Chama ambas as fun√ß√µes (mas apenas uma far√° algo)
   - init_player_dir_ns() para N ou S
   - init_player_dir_ew() para E ou W

POR QUE +0.5?
[0,0]  [1,0]  [2,0]
  +------+------+
  |      |      |
  |  *   |      |  <- Player em (0.5, 0.5) = centro da c√©lula
  +------+------+
[0,1]  [1,1]  [2,1]

--------------------------------------------------------------------------------
TEXTURE_UTILS.C
--------------------------------------------------------------------------------

static void parse_texture_line(char **lines, int i, t_game *game, int *found)
--------------------------------------------------------------------------------
PROP√ìSITO: Processa linhas de textura Norte e Sul

FUNCIONAMENTO:
1. Norte (linha 18-24):
   - Se linha come√ßa com "NO "
   - Remove espa√ßos/newlines do caminho com ft_strtrim()
   - Carrega textura com load_texture()
   - Libera string tempor√°ria
   - Incrementa contador

2. Sul (linha 25-31):
   - Mesma l√≥gica para "SO "

EXEMPLO DE LINHA:
NO ./textures/wall_north.xpm\n
   ^^^^^^^^^^^^^^^^^^^^^^^    <- Este path √© extra√≠do e limpo

--------------------------------------------------------------------------------
static void parse_texture_line2(char **lines, int i, t_game *game, int *found)
--------------------------------------------------------------------------------
PROP√ìSITO: Processa linhas de textura Oeste e Leste

FUNCIONAMENTO:
- Mesma l√≥gica que parse_texture_line() mas para:
  - "WE " ‚Üí textura oeste
  - "EA " ‚Üí textura leste

POR QUE DUAS FUN√á√ïES?
- Limita√ß√£o da Norminette: m√°ximo 25 linhas por fun√ß√£o
- Dividir em duas mant√©m conformidade

--------------------------------------------------------------------------------
void parse_config_line(char **lines, int i, t_game *game, int *found)
--------------------------------------------------------------------------------
PROP√ìSITO: Roteador principal que processa todas as linhas de configura√ß√£o

FUNCIONAMENTO:
1. Texturas (linha 51-52):
   - Chama parse_texture_line() e parse_texture_line2()
   - Cada uma checa seus tipos espec√≠ficos

2. Cor do ch√£o (linha 53-57):
   - Se linha come√ßa com "F "
   - Chama parse_color() para converter RGB
   - Incrementa contador

3. Cor do teto (linha 58-62):
   - Se linha come√ßa com "C "
   - Mesma l√≥gica para teto

EXEMPLO DE ARQUIVO .CUB:
NO ./north.xpm    <- parse_texture_line processa
SO ./south.xpm    <- parse_texture_line processa
WE ./west.xpm     <- parse_texture_line2 processa
EA ./east.xpm     <- parse_texture_line2 processa
F 100,100,100     <- Esta fun√ß√£o processa
C 50,150,200      <- Esta fun√ß√£o processa

================================================================================
üéÆ 4. RAYCASTING - Motor de Renderiza√ß√£o 3D
================================================================================

--------------------------------------------------------------------------------
RAYCASTING.C
--------------------------------------------------------------------------------

void raycasting(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Loop principal que renderiza todos os raios da tela

FUNCIONAMENTO DETALHADO:
1. Loop por coluna (linha 19):
   - x vai de 0 a WINDOW_WIDTH (1024 pixels)
   - Cada coluna = 1 raio

2. Para cada raio:
   - Inicializa (linha 21): init_ray() calcula dire√ß√£o
   - Lan√ßa (linha 22): perform_dda() encontra parede
   - Calcula dist√¢ncia (linha 23): calculate_wall_distance()
   - Desenha (linha 24): draw_wall() renderiza coluna

VISUALIZA√á√ÉO:
Tela:  |  |  |  |  |  |  |
       ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì  ‚Üì
       Raios disparados

--------------------------------------------------------------------------------
void init_ray(t_ray *ray, t_player *player, int x)
--------------------------------------------------------------------------------
PROP√ìSITO: Configura um raio para a coluna x da tela

FUNCIONAMENTO MATEM√ÅTICO:

1. Camera X (linha 28):
   camera_x = 2 * x / WINDOW_WIDTH - 1
   - Converte pixel X (0 a 1024) em range (-1 a 1)
   - -1 = esquerda, 0 = centro, 1 = direita

2. Dire√ß√£o do raio (linha 29-30):
   ray_dir_x = dir_x + plane_x * camera_x
   ray_dir_y = dir_y + plane_y * camera_x
   - Combina dire√ß√£o de vis√£o com plano de c√¢mera
   - camera_x varia ao longo do plano

3. Posi√ß√£o inicial (linha 31-32):
   - Come√ßa na posi√ß√£o do jogador (inteiro)
   - (int)player->x trunca para c√©lula do grid

4. Delta distances (linha 33-38):
   delta_dist_x = |1 / ray_dir_x|
   delta_dist_y = |1 / ray_dir_y|
   - Dist√¢ncia que o raio percorre para atravessar 1 c√©lula
   - Se ray_dir = 0, usa 1e30 (infinito)

DIAGRAMA DO RAIO:
     Plano de c√¢mera
    ‚Üê----------------‚Üí
    |                |
    |    camera_x    |
    |  ‚Üô          ‚Üò  |
    Player ‚Üí dir_x, dir_y
         ‚Üò
          Ray para pixel X

--------------------------------------------------------------------------------
void calculate_wall_distance(t_ray *ray, t_player *player)
--------------------------------------------------------------------------------
PROP√ìSITO: Calcula dist√¢ncia perpendicular at√© a parede e altura da linha

FUNCIONAMENTO:

1. Dist√¢ncia perpendicular (linha 44-49):
   if (ray->side == 0)  // Parede vertical (X)
       perp_wall_dist = (map_x - player->x + (1 - step_x) / 2) / ray_dir_x
   else  // Parede horizontal (Y)
       perp_wall_dist = (map_y - player->y + (1 - step_y) / 2) / ray_dir_y
   
   POR QUE PERPENDICULAR?
   - Evita efeito "olho de peixe"
   - Dist√¢ncia real do raio causaria distor√ß√£o nas bordas

2. Prote√ß√£o contra divis√£o por zero (linha 50-51):
   - Se dist√¢ncia ‚â§ 0, define como muito pequeno (1e-6)

3. Altura da linha (linha 52):
   line_height = WINDOW_HEIGHT / perp_wall_dist
   - Quanto mais longe, menor a linha
   - Exemplo: dist=1 ‚Üí height=768, dist=2 ‚Üí height=384

4. Limites de desenho (linha 53-58):
   - draw_start: onde come√ßar a desenhar (pode ser negativo)
   - draw_end: onde parar
   - Clamp para n√£o desenhar fora da tela

VISUALIZA√á√ÉO:
     0 ‚Üê‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí WINDOW_HEIGHT (768)
     |                |
     |   draw_start   |
     |   ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó    |  ‚Üê Parede renderizada
     |   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù    |
     |    draw_end    |
     |                |

--------------------------------------------------------------------------------
DDA.C (Digital Differential Analysis)
--------------------------------------------------------------------------------

void perform_dda(t_ray *ray, t_player *player, char **map)
--------------------------------------------------------------------------------
PROP√ìSITO: Algoritmo que "caminha" pelo grid at√© encontrar uma parede

FUNCIONAMENTO DO ALGORITMO DDA:

1. Inicializa√ß√£o (linha 17):
   - calculate_step_and_side_dist() prepara dist√¢ncias

2. Loop at√© hit (linha 18-32):
   while (ray->hit == 0)
   - Para quando encontrar parede ('1')

3. Escolhe dire√ß√£o (linha 20-31):
   - Se side_dist_x < side_dist_y: avan√ßa em X
     * Incrementa side_dist_x por delta_dist_x
     * Move map_x por step_x (-1 ou +1)
     * Marca side = 0 (parede vertical)
   
   - Sen√£o: avan√ßa em Y
     * Incrementa side_dist_y por delta_dist_y
     * Move map_y por step_y
     * Marca side = 1 (parede horizontal)

4. Verifica hit (linha 32-33):
   - Se c√©lula atual √© '1', marca hit = 1

VISUALIZA√á√ÉO DO CAMINHO DO RAIO:
Grid:
  0   1   2   3
0 [1] [1] [1] [1]
1 [1] [P] [0] [1]
2 [1] [0] [0] [1]
3 [1] [1] [1] [1]

Raio:  P ‚Üí ‚Üí ‚Üí 1
      (1,1) (2,1) (3,1)
       ‚Üì     ‚Üì     ‚Üì HIT!
    Passo  Passo  Parede

--------------------------------------------------------------------------------
void calculate_step_and_side_dist(t_ray *ray, t_player *player)
--------------------------------------------------------------------------------
PROP√ìSITO: Calcula dire√ß√£o de passo e dist√¢ncias iniciais para DDA

FUNCIONAMENTO PARA X (linha 36-45):

1. Se ray_dir_x < 0 (raio indo para esquerda):
   - step_x = -1: vai para c√©lula anterior
   - side_dist_x = (player->x - map_x) * delta_dist_x
   - Dist√¢ncia at√© borda esquerda da c√©lula

2. Se ray_dir_x > 0 (raio indo para direita):
   - step_x = 1: vai para pr√≥xima c√©lula
   - side_dist_x = (map_x + 1.0 - player->x) * delta_dist_x
   - Dist√¢ncia at√© borda direita da c√©lula

MESMA L√ìGICA PARA Y (linha 46-55)

DIAGRAMA:
C√©lula atual:
   map_x      map_x+1
     |           |
     +-----*-----+  <- Player em posi√ß√£o fracion√°ria
     |    P‚Üí     |
     |           |
     +-----‚ö°----+  <- side_dist_x = dist√¢ncia at√© pr√≥xima borda
           ‚Üë
       Pr√≥xima borda

================================================================================
üé® 5. GRAPHICS - Renderiza√ß√£o Visual
================================================================================

--------------------------------------------------------------------------------
RENDERER.C
--------------------------------------------------------------------------------

int render_frame(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Fun√ß√£o chamada a cada frame (~60 FPS)

ORDEM DE RENDERIZA√á√ÉO:
1. Move jogador (linha 17):
   - move_player() atualiza posi√ß√£o baseado em teclas

2. Desenha fundo (linha 18):
   - draw_background() pinta teto e ch√£o

3. Raycasting (linha 19):
   - raycasting() desenha todas as paredes

4. Minimap (linha 20):
   - draw_minimap() adiciona HUD no canto

5. Atualiza tela (linha 21):
   - mlx_put_image_to_window() mostra buffer na janela

POR QUE ESSA ORDEM?
- Fundo primeiro (mais distante)
- Paredes por cima
- HUD por √∫ltimo (mais pr√≥ximo)

--------------------------------------------------------------------------------
void draw_background(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Pinta teto e ch√£o com cores s√≥lidas

FUNCIONAMENTO:

1. Teto (linha 26-36):
   - Metade superior da tela (0 a HEIGHT/2)
   - Usa ceiling_color.hex
   - Loop duplo: cada pixel

2. Ch√£o (linha 37-46):
   - Metade inferior (HEIGHT/2 a HEIGHT)
   - Usa floor_color.hex
   - Loop duplo: cada pixel

RESULTADO VISUAL:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                ‚îÇ ‚Üê Teto (cor C)
‚îÇ                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚Üê Meio da tela
‚îÇ                ‚îÇ
‚îÇ                ‚îÇ ‚Üê Ch√£o (cor F)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

--------------------------------------------------------------------------------
void put_pixel(t_img *img, int x, int y, int color)
--------------------------------------------------------------------------------
PROP√ìSITO: Coloca um pixel colorido na imagem (buffer)

FUNCIONAMENTO:

1. Bounds check (linha 55):
   - Verifica se (x,y) est√° dentro da janela
   - Evita crash por acesso inv√°lido

2. Calcula endere√ßo (linha 57-58):
   dst = addr + (y * line_length + x * (bits_per_pixel / 8))
   - addr: ponteiro base do buffer
   - y * line_length: pula para linha correta
   - x * (bits_per_pixel / 8): pula para coluna
   - Normalmente: bits_per_pixel = 32 (4 bytes por pixel)

3. Escreve cor (linha 59):
   *(unsigned int *)dst = color
   - Cast para unsigned int* (4 bytes)
   - Escreve valor hexadecimal (0xRRGGBB)

MEM√ìRIA DO BUFFER:
[R][G][B][A] [R][G][B][A] [R][G][B][A] ...
 Pixel 0,0    Pixel 1,0    Pixel 2,0

--------------------------------------------------------------------------------
DRAW_WALL.C
--------------------------------------------------------------------------------

static t_img *select_texture(t_game *game, t_ray *ray)
--------------------------------------------------------------------------------
PROP√ìSITO: Escolhe qual textura usar baseado na dire√ß√£o da parede

L√ìGICA DE SELE√á√ÉO:

1. Paredes verticais (side == 0):
   - Se raio vai para direita (ray_dir_x > 0): textura LESTE
   - Se raio vai para esquerda: textura OESTE

2. Paredes horizontais (side == 1):
   - Se raio vai para baixo (ray_dir_y > 0): textura SUL
   - Se raio vai para cima: textura NORTE

DIAGRAMA:
        Norte (ray_dir_y < 0)
            ‚Üë
            |
Oeste ‚Üê----P----‚Üí Leste
  (dir_x<0)|  (dir_x>0)
            ‚Üì
        Sul (ray_dir_y > 0)

--------------------------------------------------------------------------------
static void draw_no_texture(t_game *game, t_ray *ray, int x)
--------------------------------------------------------------------------------
PROP√ìSITO: Fallback caso textura n√£o carregue

FUNCIONAMENTO:
- Desenha linha vertical branca
- De draw_start at√© draw_end
- Cor 0xFFFFFF (branco puro)

--------------------------------------------------------------------------------
static void calculate_texture_params(t_ray *ray, t_img *texture, 
                                     t_player *player, int *tex_x)
--------------------------------------------------------------------------------
PROP√ìSITO: Calcula qual coluna da textura usar (coordenada X)

FUNCIONAMENTO MATEM√ÅTICO:

1. Calcula wall_x (linha 51-54):
   if (side == 0)  // Parede vertical
       wall_x = player->y + perp_wall_dist * ray_dir_y
   else           // Parede horizontal
       wall_x = player->x + perp_wall_dist * ray_dir_x
   - Posi√ß√£o exata onde raio atingiu a parede
   - Exemplo: 5.75 (75% ao longo da parede)

2. Parte fracion√°ria (linha 55):
   wall_x -= floor(wall_x)
   - Remove parte inteira: 5.75 ‚Üí 0.75
   - Agora est√° entre 0.0 e 1.0

3. Mapeia para textura (linha 56):
   tex_x = (int)(wall_x * texture->width)
   - Se texture->width = 64 e wall_x = 0.75
   - tex_x = 48 (coluna 48 da textura)

4. Inverte se necess√°rio (linha 57-59):
   - Algumas dire√ß√µes precisam espelhar textura
   - tex_x = width - tex_x - 1

VISUALIZA√á√ÉO:
Parede real:     Textura (64x64):
   0.0 ... 0.75     0 ... 48
    |||||||||||||   ||||||||||||
    ‚Üì hit aqui      ‚Üì usa esta coluna

--------------------------------------------------------------------------------
static void draw_textured_line(t_game *game, t_ray *ray, t_img *texture, int x)
--------------------------------------------------------------------------------
PROP√ìSITO: Desenha uma coluna vertical texturizada

FUNCIONAMENTO:

1. Calcula tex_x (linha 70):
   - Chama calculate_texture_params() para coluna da textura

2. Prepara step e posi√ß√£o (linha 71-73):
   tex_step_pos[0] = texture->height / line_height  // Step
   tex_step_pos[1] = (draw_start - HEIGHT/2 + line_height/2) * step  // Pos
   - step: quanto avan√ßar na textura por pixel de tela
   - pos: posi√ß√£o inicial na textura (pode ser negativa se parede muito perto)

3. Loop de pixels (linha 74-81):
   - Para cada pixel Y da tela:
     * Calcula tex_y usando tex_pos
     * M√°scara & (height - 1) garante ficar no range
     * Pega cor da textura em (tex_x, tex_y)
     * Desenha pixel
     * Avan√ßa tex_pos por step

VISUALIZA√á√ÉO:
Textura (64x64):     Tela:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îå‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         ‚îÇ         ‚îÇ   ‚îÇ draw_start
‚îÇ    ‚Üï    ‚îÇ  map    ‚îÇ ‚Üï ‚îÇ Estica/comprime
‚îÇ   64px  ‚îÇ  ‚îÄ‚îÄ‚Üí    ‚îÇ200‚îÇ baseado em dist√¢ncia
‚îÇ         ‚îÇ         ‚îÇ   ‚îÇ draw_end
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îî‚îÄ‚îÄ‚îÄ‚îò
  tex_x=30            x

--------------------------------------------------------------------------------
void draw_wall(t_game *game, t_ray *ray, int x)
--------------------------------------------------------------------------------
PROP√ìSITO: Fun√ß√£o principal que coordena desenho da parede

FUNCIONAMENTO:
1. Seleciona textura apropriada
2. Se NULL, desenha branco
3. Sen√£o, desenha linha texturizada

--------------------------------------------------------------------------------
TEXTURES.C
--------------------------------------------------------------------------------

static int check_file_exists(char *path)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se arquivo de textura existe antes de carregar

FUNCIONAMENTO:
1. Tenta abrir arquivo em modo leitura
2. Se fd < 0, retorna 0 (n√£o existe)
3. Fecha arquivo imediatamente
4. Retorna 1 (existe)

POR QUE N√ÉO APENAS TENTAR CARREGAR?
- MLX pode crashar se arquivo n√£o existir
- Melhor validar antes

--------------------------------------------------------------------------------
t_img *load_texture(t_game *game, char *path)
--------------------------------------------------------------------------------
PROP√ìSITO: Carrega arquivo XPM como textura

FUNCIONAMENTO DETALHADO:

1. Verifica exist√™ncia (linha 28-29):
   - Se arquivo n√£o existe, retorna NULL

2. Aloca estrutura (linha 30-32):
   - malloc(sizeof(t_img))
   - Se falhar, retorna NULL

3. Carrega XPM (linha 33-39):
   mlx_xpm_file_to_image(mlx, path, &width, &height)
   - MLX l√™ arquivo XPM
   - Cria imagem interna
   - Preenche width e height automaticamente
   - Se falhar, libera estrutura e retorna NULL

4. Obt√©m buffer (linha 40-41):
   mlx_get_data_addr(img, &bits_per_pixel, &line_length, &endian)
   - Pega ponteiro direto para pixels da textura
   - Permite acesso r√°pido sem chamadas MLX

FORMATO XPM:
/* XPM */
static char *wall[] = {
"64 64 2 1",     ‚Üê width height colors chars_per_pixel
". c #FFFFFF",   ‚Üê cor 1
"# c #000000",   ‚Üê cor 2
"####............",  ‚Üê pixels linha 1
...
};

--------------------------------------------------------------------------------
int get_texture_color(t_img *texture, int x, int y)
--------------------------------------------------------------------------------
PROP√ìSITO: Obt√©m cor de um pixel espec√≠fico da textura

FUNCIONAMENTO:

1. Valida√ß√£o (linha 49-50):
   - Verifica se texture n√£o √© NULL
   - Verifica se (x,y) est√° dentro dos limites

2. Calcula endere√ßo (linha 51-52):
   dst = addr + (y * line_length + x * (bits_per_pixel / 8))
   - Mesma l√≥gica que put_pixel()
   - Mas para buffer da textura, n√£o da tela

3. Retorna cor (linha 53):
   return *(unsigned int *)dst
   - Cast para unsigned int
   - Retorna valor ARGB (0xAARRGGBB)

--------------------------------------------------------------------------------
MINIMAP.C E MINIMAP_UTILS.C
--------------------------------------------------------------------------------

static void draw_minimap_grid(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Desenha o grid do mapa no minimapa

FUNCIONAMENTO:
- Loop por cada linha do mapa (at√© caber em MINIMAP_SIZE)
- Para cada linha, chama draw_map_row()

--------------------------------------------------------------------------------
void draw_minimap_player(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Desenha ponto vermelho representando jogador

FUNCIONAMENTO:

1. Calcula posi√ß√£o na tela (linha 31-32):
   player_x = MINIMAP_MARGIN + (int)(player->x * MINIMAP_TILE_SIZE)
   player_y = MINIMAP_MARGIN + (int)(player->y * MINIMAP_TILE_SIZE)
   - Converte coordenadas do mapa para pixels da tela
   - Adiciona margem

2. Desenha quadrado 5x5 (linha 33-47):
   - Loop -2 a +2 em ambas dire√ß√µes
   - Cor vermelha (0xFF0000)
   - Verifica bounds para n√£o sair do minimapa

--------------------------------------------------------------------------------
void draw_minimap(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Fun√ß√£o principal que orquestra desenho do minimapa

ORDEM:
1. Fundo preto
2. Grid do mapa
3. Posi√ß√£o do jogador

--------------------------------------------------------------------------------
void draw_minimap_tile(t_game *game, int x, int y, int color)
--------------------------------------------------------------------------------
PROP√ìSITO: Desenha um quadrado MINIMAP_TILE_SIZE x MINIMAP_TILE_SIZE

FUNCIONAMENTO:
- Loop duplo de 0 a MINIMAP_TILE_SIZE (10 pixels)
- Pinta cada pixel com a cor especificada

--------------------------------------------------------------------------------
void draw_minimap_background(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Pinta fundo preto do minimapa

FUNCIONAMENTO:
- Loop de MINIMAP_MARGIN at√© MINIMAP_MARGIN + MINIMAP_SIZE
- Pinta cada pixel de preto (0x000000)

--------------------------------------------------------------------------------
int get_tile_color(t_game *game, int map_y, int map_x)
--------------------------------------------------------------------------------
PROP√ìSITO: Retorna cor apropriada para c√©lula do mapa

L√ìGICA DE CORES:
- '1' (parede): Branco (0xFFFFFF)
- '0' ou jogador: Cinza (0x808080)
- Outros: Preto (0x000000)

--------------------------------------------------------------------------------
void draw_map_row(t_game *game, int map_y)
--------------------------------------------------------------------------------
PROP√ìSITO: Desenha uma linha horizontal do mapa

FUNCIONAMENTO:
1. Loop por cada coluna
2. Pega cor com get_tile_color()
3. Desenha tile com draw_minimap_tile()

================================================================================
üéÆ 6. PLAYER - Controles e Movimento
================================================================================

--------------------------------------------------------------------------------
MOVEMENT.C
--------------------------------------------------------------------------------

static void process_wasd_keys(t_game *game, double *new_x, double *new_y)
--------------------------------------------------------------------------------
PROP√ìSITO: Processa teclas WASD para movimento

FUNCIONAMENTO:

1. W - Frente (linha 17-21):
   new_x += dir_x * MOVE_SPEED
   new_y += dir_y * MOVE_SPEED
   - Move na dire√ß√£o que est√° olhando

2. S - Tr√°s (linha 22-26):
   new_x -= dir_x * MOVE_SPEED
   new_y -= dir_y * MOVE_SPEED
   - Move na dire√ß√£o oposta

3. A - Esquerda (strafe) (linha 27-31):
   new_x += dir_y * MOVE_SPEED
   new_y -= dir_x * MOVE_SPEED
   - Vetor perpendicular √† dire√ß√£o (90¬∞ esquerda)

4. D - Direita (strafe) (linha 32-36):
   new_x -= dir_y * MOVE_SPEED
   new_y += dir_x * MOVE_SPEED
   - Vetor perpendicular √† dire√ß√£o (90¬∞ direita)

DIAGRAMA DE MOVIMENTO:
        W (frente)
          ‚Üë
    A ‚Üê   P   ‚Üí D  (strafes laterais)
          ‚Üì
        S (tr√°s)

--------------------------------------------------------------------------------
void move_player(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Atualiza posi√ß√£o e rota√ß√£o do jogador

FUNCIONAMENTO:

1. Inicializa posi√ß√£o (linha 41-42):
   - Come√ßa com posi√ß√£o atual

2. Processa WASD (linha 43):
   - Calcula nova posi√ß√£o desejada

3. Aplica com colis√£o (linha 44-47):
   - Tenta mover X: se n√£o colidir, atualiza player->x
   - Tenta mover Y: se n√£o colidir, atualiza player->y
   - SEPARADO: permite "deslizar" ao longo de paredes

4. Rota√ß√£o (linha 48-51):
   - Seta esquerda: rotaciona -ROT_SPEED (-0.03 rad/frame)
   - Seta direita: rotaciona +ROT_SPEED (+0.03 rad/frame)

POR QUE X E Y SEPARADOS?
Cen√°rio: Player quer ir diagonal mas h√° parede em X

    X ‚Üí
  ‚îå‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ P ‚îÇ###‚îÇ  Sem separa√ß√£o: para completamente
  ‚îî‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îò  Com separa√ß√£o: desliza para baixo
    ‚Üì Y permitido

--------------------------------------------------------------------------------
void rotate_player(t_game *game, double angle)
--------------------------------------------------------------------------------
PROP√ìSITO: Rotaciona dire√ß√£o de vis√£o e plano de c√¢mera

MATEM√ÅTICA DA ROTA√á√ÉO:

1. Rotaciona vetor de dire√ß√£o (linha 57-60):
   new_dir_x = dir_x * cos(angle) - dir_y * sin(angle)
   new_dir_y = old_dir_x * sin(angle) + dir_y * cos(angle)
   - Matriz de rota√ß√£o 2D padr√£o
   - Preserva tamanho do vetor (magnitude = 1)

2. Rotaciona plano de c√¢mera (linha 61-64):
   - Mesma transforma√ß√£o no vetor plane
   - Mant√©m perpendicular √† dire√ß√£o

MATRIZ DE ROTA√á√ÉO:
[cos Œ∏  -sin Œ∏] [x]   [x']
[sin Œ∏   cos Œ∏] [y] = [y']

VISUALIZA√á√ÉO:
Antes:          Depois (rota√ß√£o +30¬∞):
    ‚Üë               ‚Üó
    |              /
    P            P

--------------------------------------------------------------------------------
COLLISION.C
--------------------------------------------------------------------------------

static int check_position(t_game *game, int map_x, int map_y)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica se uma c√©lula espec√≠fica bloqueia movimento

FUNCIONAMENTO:

1. Bounds check (linha 18-19):
   - Se (map_x, map_y) fora do mapa, retorna 1 (colide)

2. Verifica c√©lula (linha 20-26):
   - Se dentro dos limites E √≠ndice v√°lido
   - Verifica se √© '1' (parede)
   - Retorna 1 se parede, 0 se livre

3. Fora do mapa (linha 27):
   - Se c√©lula n√£o existe, considera colis√£o

--------------------------------------------------------------------------------
int check_collision(t_game *game, double new_x, double new_y)
--------------------------------------------------------------------------------
PROP√ìSITO: Verifica colis√£o considerando raio do jogador

FUNCIONAMENTO DETALHADO:

1. Define offsets (linha 35-36):
   offs[0] = -PLAYER_RADIUS  // -0.2
   offs[1] = +PLAYER_RADIUS  // +0.2

2. Verifica 4 cantos (linha 38-49):
   - Loop duplo cria 4 combina√ß√µes:
     * (-0.2, -0.2): canto superior esquerdo
     * (-0.2, +0.2): canto superior direito
     * (+0.2, -0.2): canto inferior esquerdo
     * (+0.2, +0.2): canto inferior direito

3. Para cada canto:
   - Converte para coordenada de c√©lula (int)
   - Chama check_position()
   - Se qualquer colidir, retorna 1

4. Se nenhum colidir, retorna 0

VISUALIZA√á√ÉO DO HITBOX:
    (-0.2,-0.2)  (+0.2,-0.2)
         ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè
         ‚îÇ   P    ‚îÇ  ‚Üê Player radius = 0.2
         ‚óè‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚óè
    (-0.2,+0.2)  (+0.2,+0.2)

Verifica se algum canto est√° em parede

================================================================================
üßπ 7. UTILS - Utilit√°rios
================================================================================

--------------------------------------------------------------------------------
CLEANUP.C
--------------------------------------------------------------------------------

static void cleanup_map(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Libera array de strings do mapa

FUNCIONAMENTO:
1. Loop por cada linha
2. free() em cada string
3. free() no array principal

--------------------------------------------------------------------------------
static void cleanup_textures_helper(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Libera todas as 4 texturas

FUNCIONAMENTO:
- Para cada textura (north, south, west, east):
  - Se n√£o for NULL, chama cleanup_texture()
- Libera estrutura t_texture

--------------------------------------------------------------------------------
void cleanup_game(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Libera TODA a mem√≥ria alocada

ORDEM DE LIMPEZA:
1. Mapa
2. Texturas
3. Imagem principal
4. Jogador
5. Janela MLX
6. Display MLX

CR√çTICO: Esta fun√ß√£o previne memory leaks!

--------------------------------------------------------------------------------
void cleanup_texture(t_game *game, t_img *texture)
--------------------------------------------------------------------------------
PROP√ìSITO: Libera uma textura espec√≠fica

FUNCIONAMENTO:
1. Destr√≥i imagem MLX
2. Libera estrutura t_img

--------------------------------------------------------------------------------
ERROR.C
--------------------------------------------------------------------------------

void error_exit(char *message)
--------------------------------------------------------------------------------
PROP√ìSITO: Imprime erro e termina programa

FUNCIONAMENTO:
- printf(message)
- exit(1) - c√≥digo de erro

--------------------------------------------------------------------------------
int key_press(int keycode, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Handler quando tecla √© pressionada

FUNCIONAMENTO:

1. ESC (linha 22-23):
   - Fecha janela imediatamente

2. Teclas normais (linha 24-25):
   - Marca keys[keycode] = 1
   - Exemplo: W pressionado ‚Üí keys[119] = 1

3. Setas especiais (linha 26-29):
   - C√≥digos diferentes, usa √≠ndices especiais
   - LEFT ‚Üí keys[KEY_LEFT_IDX]
   - RIGHT ‚Üí keys[KEY_RIGHT_IDX]

POR QUE ARRAY DE KEYS?
- Permite m√∫ltiplas teclas simultaneamente
- W+A = movimento diagonal
- W+Seta = mover e rotacionar ao mesmo tempo

--------------------------------------------------------------------------------
int key_release(int keycode, t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Handler quando tecla √© solta

FUNCIONAMENTO:
- Marca keys[keycode] = 0
- Mesma l√≥gica para setas especiais

--------------------------------------------------------------------------------
int close_window(t_game *game)
--------------------------------------------------------------------------------
PROP√ìSITO: Fecha o programa de forma limpa

FUNCIONAMENTO:
1. Chama cleanup_game() para liberar mem√≥ria
2. exit(0) - c√≥digo de sucesso

--------------------------------------------------------------------------------
MATH_UTILS.C
--------------------------------------------------------------------------------

int create_rgb(int r, int g, int b)
--------------------------------------------------------------------------------
PROP√ìSITO: Combina componentes RGB em um inteiro hexadecimal

FUNCIONAMENTO MATEM√ÅTICO:
return (r << 16 | g << 8 | b)

EXPLICA√á√ÉO BIT A BIT:
- r << 16: desloca R para posi√ß√£o 16-23
- g << 8: desloca G para posi√ß√£o 8-15
- b: fica em posi√ß√£o 0-7
- |: OR bit a bit combina tudo

EXEMPLO:
r = 255 (0xFF)
g = 100 (0x64)
b = 50  (0x32)

r << 16 = 0x00FF0000
g << 8  = 0x00006400
b       = 0x00000032
        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
OR      = 0x00FF6432

RESULTADO: 0xFF6432 (laranja)

================================================================================
üéØ RESUMO DO FLUXO COMPLETO
================================================================================

1. INICIALIZA√á√ÉO (main.c):
   main() ‚Üí valida args ‚Üí init_game() ‚Üí parse_file() ‚Üí game_loop()

2. PARSING (parsing/):
   parse_file() ‚Üí read_lines() ‚Üí parse_textures() + parse_map() ‚Üí validate_map()

3. GAME LOOP (chamado ~60x por segundo):
   render_frame() ‚Üí move_player() ‚Üí draw_background() ‚Üí raycasting() ‚Üí draw_minimap()

4. RAYCASTING (para cada coluna da tela):
   init_ray() ‚Üí perform_dda() ‚Üí calculate_wall_distance() ‚Üí draw_wall()

5. CLEANUP (ao fechar):
   close_window() ‚Üí cleanup_game() ‚Üí libera tudo ‚Üí exit()

================================================================================
üìä ESTRUTURAS DE DADOS PRINCIPAIS
================================================================================

t_game: Estrutura central que cont√©m tudo
- mlx: Conex√£o com X11
- win: Janela
- img: Buffer de desenho
- map: Mapa 2D
- textures: 4 texturas
- player: Posi√ß√£o e dire√ß√£o
- keys: Estado das teclas

t_player: Estado do jogador
- x, y: Posi√ß√£o no mapa
- dir_x, dir_y: Dire√ß√£o de vis√£o
- plane_x, plane_y: Plano de c√¢mera (FOV)

t_ray: Dados de um raio
- ray_dir_x, ray_dir_y: Dire√ß√£o do raio
- map_x, map_y: C√©lula atual
- perp_wall_dist: Dist√¢ncia at√© parede
- hit: Encontrou parede?
- side: Vertical ou horizontal?

================================================================================
üèÜ CARACTER√çSTICAS DO PROJETO
================================================================================

‚úÖ 100% conforme a Norminette (Escola 42)
‚úÖ Sem leaks de mem√≥ria (testado com Valgrind)
‚úÖ Raycasting em tempo real (~60 FPS)
‚úÖ Texturas XPM customiz√°veis
‚úÖ Detec√ß√£o de colis√£o suave
‚úÖ Minimapa em tempo real (bonus)
‚úÖ Cores de ch√£o e teto configur√°veis
‚úÖ Movimento WASD + rota√ß√£o com setas

================================================================================
üìù CONTROLES
================================================================================

W - Mover para frente
S - Mover para tr√°s
A - Strafe esquerda
D - Strafe direita
‚Üê - Rotacionar c√¢mera √† esquerda
‚Üí - Rotacionar c√¢mera √† direita
ESC - Fechar programa

================================================================================
FIM DA DOCUMENTA√á√ÉO
================================================================================
